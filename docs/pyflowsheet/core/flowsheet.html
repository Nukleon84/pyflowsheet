<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyflowsheet.core.flowsheet API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyflowsheet.core.flowsheet</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .stream import Stream
from ..annotations import TextElement
from pathfinding.core.grid import Grid


class Flowsheet(object):
    def __init__(self, id: str, name: str, description: str = &#34;&#34;):
        &#34;&#34;&#34;Generates a new Flowsheet Object. The Flowsheet object represent a Process Flow Diagram (PFD). A Flowsheet
        is made up of unit operations, streams and annotations.

        Args:
            id (str): Short identifier of the flowsheet
            name (str): A human readable, longer name
            description (str, optional): A text that describes the process task of the flowsheet. Defaults to &#34;&#34;.
        &#34;&#34;&#34;
        self.id = id
        self.name = name
        self.description = description
        self.lineColor = (64, 64, 64, 255)
        self.fillColor = (255, 255, 255, 255)
        self.textColor = (0, 0, 0, 255)
        self.size = (512, 512)
        self.position = (0, 0)
        self.lineSize = 2
        self.unitOperations = {}
        self.annotations = []
        self.streams = {}
        self.showGrid = False

    def addAnnotations(self, elements):
        for e in elements:
            self.annotations.append(e)
        return

    def addUnits(self, units):
        &#34;&#34;&#34;Add a list of units to the flowsheet in one go.

        Args:
            units (List[UnitOperation]): A list of UnitOperation objects
        &#34;&#34;&#34;
        for u in units:
            self.unitOperations[u.id] = u
        return

    def unit(self, unitoperation):
        &#34;&#34;&#34;Add a new unit operation to the flowsheet and return a reference

        Raises:
            ValueError: If None is passed this function will raise a ValueError.
                        If the id of the UnitOperation is already present in the flowsheet a value error will be raised.

        Returns:
            UnitOperation: The UnitOperation object passed into the function as an argument.
        &#34;&#34;&#34;
        if unitoperation is None:
            raise ValueError(
                &#34;unitoperation must be an object derived from the UnitOperation class!&#34;
            )
        if unitoperation.id in self.unitOperations:
            raise ValueError(
                &#34;The id of unitoperation is already used within the flowsheet. Please provide a unique id. If you want to override a specific unit operation, access it directly with the flowsheet.unitoperations[] accessor.&#34;
            )
        self.unitOperations[unitoperation.id] = unitoperation
        return unitoperation

    def connect(self, name, fromPort, toPort):
        &#34;&#34;&#34;Connect two ports of two unit operations with a stream.

        Args:
            name (string): The identifier/name of the stream.
            fromPort (Port): The source port from which to route the stream
            toPort (Port): The destination port to which to route the stream
        &#34;&#34;&#34;
        if name in self.streams:
            raise ValueError(
                &#34;The id of the stream is already used within the flowsheet. Please provide a unique id. If you want to override a specific stream, access it directly with the flowsheet.streams[] accessor.&#34;
            )

        self.streams[name] = Stream(name, fromPort, toPort)
        return

    def _calcGrid(self):
        &#34;&#34;&#34;Private helper function to rasterize the canvas and generate a course grid for pathfinding. This functions scans
        the entire canvas area and tests if a unit intersects the grid point. If any unit does so, the point is marked as
        &#34;impassable&#34; for the pathfinding algorithm.

        Returns:
            [2d-list]: The reachability matrix of the canvas area
            [int]    : The minimum x coordinate of the canvas (upper-left)
            [int]    : The minimum y coordinate of the canvas (upper-left)
        &#34;&#34;&#34;
        minx = min([u.position[0] for u in self.unitOperations.values()])
        maxx = max([u.position[0] + u.size[0] for u in self.unitOperations.values()])
        miny = min([u.position[1] for u in self.unitOperations.values()])
        maxy = max([u.position[1] + u.size[1] for u in self.unitOperations.values()])

        gridsize = 10

        minx = int(minx / gridsize - 8) * gridsize
        miny = int(miny / gridsize - 8) * gridsize
        maxx = int(maxx / gridsize + 8) * gridsize
        maxy = int(maxy / gridsize + 8) * gridsize

        grid = []

        for y in range(miny, maxy, gridsize):
            row = []
            for x in range(minx, maxx, gridsize):
                intersectionFound = False

                for u in self.unitOperations.values():
                    if u.intersectsPoint((x, y)):
                        intersectionFound = True

                if intersectionFound:
                    row.append(0)
                else:
                    row.append(1)
            grid.append(row)

        return grid, minx, miny

    def _drawGrid(self, grid, ctx, minx, miny):
        ctx.startGroup(&#34;RoutingGrid&#34;)

        for y in range(grid.height):
            for x in range(grid.width):
                sx = minx + x * 10
                sy = miny + y * 10
                if not grid.node(x, y).walkable:
                    ctx.circle(
                        [(sx - 5, sy - 5), (sx + 5, sy + 5)],
                        (0, 0, 0, 255),
                        (0, 0, 0, 255),
                        1,
                    )
                else:
                    w = 255 - 10 * grid.node(x, y).weight
                    w = max(w, 0)
                    ctx.circle(
                        [(sx - 5, sy - 5), (sx + 5, sy + 5)],
                        (w, w, w, 255),
                        (0, 0, 0, 255),
                        1,
                    )

        ctx.endGroup()
        return

    def callout(self, text, position):
        text = TextElement(text, position)
        self.annotations.append(text)
        return

    def draw(self, ctx):
        &#34;&#34;&#34;Draws the process flow diagram with the help of the context passed as an argument.
        This function has 3 stages. In the first stage, the reachability map of the diagram is calculated, which is used in
        the second stage to route the streams using Dykstra&#39;s algorithm. In the third stage, the unit operations are drawn.

        The unit operation draw loop has two stages. In the first stage the icon is drawn with transformations applied.
        In the second stage the text layer is drawn without any transformations (i.e. rotation) applied.

        Args:
            ctx ([type]): A drawing context that provides an abstraction for the primitive drawing functions.

        Returns:
            [type]: The same context as was passed in
        &#34;&#34;&#34;

        matrix, minx, miny = self._calcGrid()
        grid = Grid(matrix=matrix)

        for s in self.streams.values():
            ctx.startGroup(s.id)
            s.draw(ctx, grid, minx, miny)
            ctx.endGroup()

        if self.showGrid:
            self._drawGrid(grid, ctx, minx, miny)

        # print(grid.grid_str(show_weight=True))
        for u in self.unitOperations.values():
            ctx.startGroup(u.id)
            ctx.startTransformedGroup(u)
            u.draw(ctx)
            ctx.endGroup()
            u.drawTextLayer(ctx)
            ctx.endGroup()

        for e in self.annotations:
            ctx.startGroup(e.id)
            e.draw(ctx)
            e.drawTextLayer(ctx)
            ctx.endGroup()

        return ctx</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyflowsheet.core.flowsheet.Flowsheet"><code class="flex name class">
<span>class <span class="ident">Flowsheet</span></span>
<span>(</span><span>id: str, name: str, description: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a new Flowsheet Object. The Flowsheet object represent a Process Flow Diagram (PFD). A Flowsheet
is made up of unit operations, streams and annotations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>Short identifier of the flowsheet</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>A human readable, longer name</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text that describes the process task of the flowsheet. Defaults to "".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Flowsheet(object):
    def __init__(self, id: str, name: str, description: str = &#34;&#34;):
        &#34;&#34;&#34;Generates a new Flowsheet Object. The Flowsheet object represent a Process Flow Diagram (PFD). A Flowsheet
        is made up of unit operations, streams and annotations.

        Args:
            id (str): Short identifier of the flowsheet
            name (str): A human readable, longer name
            description (str, optional): A text that describes the process task of the flowsheet. Defaults to &#34;&#34;.
        &#34;&#34;&#34;
        self.id = id
        self.name = name
        self.description = description
        self.lineColor = (64, 64, 64, 255)
        self.fillColor = (255, 255, 255, 255)
        self.textColor = (0, 0, 0, 255)
        self.size = (512, 512)
        self.position = (0, 0)
        self.lineSize = 2
        self.unitOperations = {}
        self.annotations = []
        self.streams = {}
        self.showGrid = False

    def addAnnotations(self, elements):
        for e in elements:
            self.annotations.append(e)
        return

    def addUnits(self, units):
        &#34;&#34;&#34;Add a list of units to the flowsheet in one go.

        Args:
            units (List[UnitOperation]): A list of UnitOperation objects
        &#34;&#34;&#34;
        for u in units:
            self.unitOperations[u.id] = u
        return

    def unit(self, unitoperation):
        &#34;&#34;&#34;Add a new unit operation to the flowsheet and return a reference

        Raises:
            ValueError: If None is passed this function will raise a ValueError.
                        If the id of the UnitOperation is already present in the flowsheet a value error will be raised.

        Returns:
            UnitOperation: The UnitOperation object passed into the function as an argument.
        &#34;&#34;&#34;
        if unitoperation is None:
            raise ValueError(
                &#34;unitoperation must be an object derived from the UnitOperation class!&#34;
            )
        if unitoperation.id in self.unitOperations:
            raise ValueError(
                &#34;The id of unitoperation is already used within the flowsheet. Please provide a unique id. If you want to override a specific unit operation, access it directly with the flowsheet.unitoperations[] accessor.&#34;
            )
        self.unitOperations[unitoperation.id] = unitoperation
        return unitoperation

    def connect(self, name, fromPort, toPort):
        &#34;&#34;&#34;Connect two ports of two unit operations with a stream.

        Args:
            name (string): The identifier/name of the stream.
            fromPort (Port): The source port from which to route the stream
            toPort (Port): The destination port to which to route the stream
        &#34;&#34;&#34;
        if name in self.streams:
            raise ValueError(
                &#34;The id of the stream is already used within the flowsheet. Please provide a unique id. If you want to override a specific stream, access it directly with the flowsheet.streams[] accessor.&#34;
            )

        self.streams[name] = Stream(name, fromPort, toPort)
        return

    def _calcGrid(self):
        &#34;&#34;&#34;Private helper function to rasterize the canvas and generate a course grid for pathfinding. This functions scans
        the entire canvas area and tests if a unit intersects the grid point. If any unit does so, the point is marked as
        &#34;impassable&#34; for the pathfinding algorithm.

        Returns:
            [2d-list]: The reachability matrix of the canvas area
            [int]    : The minimum x coordinate of the canvas (upper-left)
            [int]    : The minimum y coordinate of the canvas (upper-left)
        &#34;&#34;&#34;
        minx = min([u.position[0] for u in self.unitOperations.values()])
        maxx = max([u.position[0] + u.size[0] for u in self.unitOperations.values()])
        miny = min([u.position[1] for u in self.unitOperations.values()])
        maxy = max([u.position[1] + u.size[1] for u in self.unitOperations.values()])

        gridsize = 10

        minx = int(minx / gridsize - 8) * gridsize
        miny = int(miny / gridsize - 8) * gridsize
        maxx = int(maxx / gridsize + 8) * gridsize
        maxy = int(maxy / gridsize + 8) * gridsize

        grid = []

        for y in range(miny, maxy, gridsize):
            row = []
            for x in range(minx, maxx, gridsize):
                intersectionFound = False

                for u in self.unitOperations.values():
                    if u.intersectsPoint((x, y)):
                        intersectionFound = True

                if intersectionFound:
                    row.append(0)
                else:
                    row.append(1)
            grid.append(row)

        return grid, minx, miny

    def _drawGrid(self, grid, ctx, minx, miny):
        ctx.startGroup(&#34;RoutingGrid&#34;)

        for y in range(grid.height):
            for x in range(grid.width):
                sx = minx + x * 10
                sy = miny + y * 10
                if not grid.node(x, y).walkable:
                    ctx.circle(
                        [(sx - 5, sy - 5), (sx + 5, sy + 5)],
                        (0, 0, 0, 255),
                        (0, 0, 0, 255),
                        1,
                    )
                else:
                    w = 255 - 10 * grid.node(x, y).weight
                    w = max(w, 0)
                    ctx.circle(
                        [(sx - 5, sy - 5), (sx + 5, sy + 5)],
                        (w, w, w, 255),
                        (0, 0, 0, 255),
                        1,
                    )

        ctx.endGroup()
        return

    def callout(self, text, position):
        text = TextElement(text, position)
        self.annotations.append(text)
        return

    def draw(self, ctx):
        &#34;&#34;&#34;Draws the process flow diagram with the help of the context passed as an argument.
        This function has 3 stages. In the first stage, the reachability map of the diagram is calculated, which is used in
        the second stage to route the streams using Dykstra&#39;s algorithm. In the third stage, the unit operations are drawn.

        The unit operation draw loop has two stages. In the first stage the icon is drawn with transformations applied.
        In the second stage the text layer is drawn without any transformations (i.e. rotation) applied.

        Args:
            ctx ([type]): A drawing context that provides an abstraction for the primitive drawing functions.

        Returns:
            [type]: The same context as was passed in
        &#34;&#34;&#34;

        matrix, minx, miny = self._calcGrid()
        grid = Grid(matrix=matrix)

        for s in self.streams.values():
            ctx.startGroup(s.id)
            s.draw(ctx, grid, minx, miny)
            ctx.endGroup()

        if self.showGrid:
            self._drawGrid(grid, ctx, minx, miny)

        # print(grid.grid_str(show_weight=True))
        for u in self.unitOperations.values():
            ctx.startGroup(u.id)
            ctx.startTransformedGroup(u)
            u.draw(ctx)
            ctx.endGroup()
            u.drawTextLayer(ctx)
            ctx.endGroup()

        for e in self.annotations:
            ctx.startGroup(e.id)
            e.draw(ctx)
            e.drawTextLayer(ctx)
            ctx.endGroup()

        return ctx</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyflowsheet.core.flowsheet.Flowsheet.addAnnotations"><code class="name flex">
<span>def <span class="ident">addAnnotations</span></span>(<span>self, elements)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addAnnotations(self, elements):
    for e in elements:
        self.annotations.append(e)
    return</code></pre>
</details>
</dd>
<dt id="pyflowsheet.core.flowsheet.Flowsheet.addUnits"><code class="name flex">
<span>def <span class="ident">addUnits</span></span>(<span>self, units)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a list of units to the flowsheet in one go.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>units</code></strong> :&ensp;<code>List[UnitOperation]</code></dt>
<dd>A list of UnitOperation objects</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addUnits(self, units):
    &#34;&#34;&#34;Add a list of units to the flowsheet in one go.

    Args:
        units (List[UnitOperation]): A list of UnitOperation objects
    &#34;&#34;&#34;
    for u in units:
        self.unitOperations[u.id] = u
    return</code></pre>
</details>
</dd>
<dt id="pyflowsheet.core.flowsheet.Flowsheet.callout"><code class="name flex">
<span>def <span class="ident">callout</span></span>(<span>self, text, position)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callout(self, text, position):
    text = TextElement(text, position)
    self.annotations.append(text)
    return</code></pre>
</details>
</dd>
<dt id="pyflowsheet.core.flowsheet.Flowsheet.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, name, fromPort, toPort)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect two ports of two unit operations with a stream.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>The identifier/name of the stream.</dd>
<dt><strong><code>fromPort</code></strong> :&ensp;<code>Port</code></dt>
<dd>The source port from which to route the stream</dd>
<dt><strong><code>toPort</code></strong> :&ensp;<code>Port</code></dt>
<dd>The destination port to which to route the stream</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, name, fromPort, toPort):
    &#34;&#34;&#34;Connect two ports of two unit operations with a stream.

    Args:
        name (string): The identifier/name of the stream.
        fromPort (Port): The source port from which to route the stream
        toPort (Port): The destination port to which to route the stream
    &#34;&#34;&#34;
    if name in self.streams:
        raise ValueError(
            &#34;The id of the stream is already used within the flowsheet. Please provide a unique id. If you want to override a specific stream, access it directly with the flowsheet.streams[] accessor.&#34;
        )

    self.streams[name] = Stream(name, fromPort, toPort)
    return</code></pre>
</details>
</dd>
<dt id="pyflowsheet.core.flowsheet.Flowsheet.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, ctx)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the process flow diagram with the help of the context passed as an argument.
This function has 3 stages. In the first stage, the reachability map of the diagram is calculated, which is used in
the second stage to route the streams using Dykstra's algorithm. In the third stage, the unit operations are drawn.</p>
<p>The unit operation draw loop has two stages. In the first stage the icon is drawn with transformations applied.
In the second stage the text layer is drawn without any transformations (i.e. rotation) applied.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ctx</code></strong> :&ensp;<code>[type]</code></dt>
<dd>A drawing context that provides an abstraction for the primitive drawing functions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>The same context as was passed in</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, ctx):
    &#34;&#34;&#34;Draws the process flow diagram with the help of the context passed as an argument.
    This function has 3 stages. In the first stage, the reachability map of the diagram is calculated, which is used in
    the second stage to route the streams using Dykstra&#39;s algorithm. In the third stage, the unit operations are drawn.

    The unit operation draw loop has two stages. In the first stage the icon is drawn with transformations applied.
    In the second stage the text layer is drawn without any transformations (i.e. rotation) applied.

    Args:
        ctx ([type]): A drawing context that provides an abstraction for the primitive drawing functions.

    Returns:
        [type]: The same context as was passed in
    &#34;&#34;&#34;

    matrix, minx, miny = self._calcGrid()
    grid = Grid(matrix=matrix)

    for s in self.streams.values():
        ctx.startGroup(s.id)
        s.draw(ctx, grid, minx, miny)
        ctx.endGroup()

    if self.showGrid:
        self._drawGrid(grid, ctx, minx, miny)

    # print(grid.grid_str(show_weight=True))
    for u in self.unitOperations.values():
        ctx.startGroup(u.id)
        ctx.startTransformedGroup(u)
        u.draw(ctx)
        ctx.endGroup()
        u.drawTextLayer(ctx)
        ctx.endGroup()

    for e in self.annotations:
        ctx.startGroup(e.id)
        e.draw(ctx)
        e.drawTextLayer(ctx)
        ctx.endGroup()

    return ctx</code></pre>
</details>
</dd>
<dt id="pyflowsheet.core.flowsheet.Flowsheet.unit"><code class="name flex">
<span>def <span class="ident">unit</span></span>(<span>self, unitoperation)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new unit operation to the flowsheet and return a reference</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If None is passed this function will raise a ValueError.
If the id of the UnitOperation is already present in the flowsheet a value error will be raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>UnitOperation</code></dt>
<dd>The UnitOperation object passed into the function as an argument.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit(self, unitoperation):
    &#34;&#34;&#34;Add a new unit operation to the flowsheet and return a reference

    Raises:
        ValueError: If None is passed this function will raise a ValueError.
                    If the id of the UnitOperation is already present in the flowsheet a value error will be raised.

    Returns:
        UnitOperation: The UnitOperation object passed into the function as an argument.
    &#34;&#34;&#34;
    if unitoperation is None:
        raise ValueError(
            &#34;unitoperation must be an object derived from the UnitOperation class!&#34;
        )
    if unitoperation.id in self.unitOperations:
        raise ValueError(
            &#34;The id of unitoperation is already used within the flowsheet. Please provide a unique id. If you want to override a specific unit operation, access it directly with the flowsheet.unitoperations[] accessor.&#34;
        )
    self.unitOperations[unitoperation.id] = unitoperation
    return unitoperation</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyflowsheet.core" href="index.html">pyflowsheet.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyflowsheet.core.flowsheet.Flowsheet" href="#pyflowsheet.core.flowsheet.Flowsheet">Flowsheet</a></code></h4>
<ul class="two-column">
<li><code><a title="pyflowsheet.core.flowsheet.Flowsheet.addAnnotations" href="#pyflowsheet.core.flowsheet.Flowsheet.addAnnotations">addAnnotations</a></code></li>
<li><code><a title="pyflowsheet.core.flowsheet.Flowsheet.addUnits" href="#pyflowsheet.core.flowsheet.Flowsheet.addUnits">addUnits</a></code></li>
<li><code><a title="pyflowsheet.core.flowsheet.Flowsheet.callout" href="#pyflowsheet.core.flowsheet.Flowsheet.callout">callout</a></code></li>
<li><code><a title="pyflowsheet.core.flowsheet.Flowsheet.connect" href="#pyflowsheet.core.flowsheet.Flowsheet.connect">connect</a></code></li>
<li><code><a title="pyflowsheet.core.flowsheet.Flowsheet.draw" href="#pyflowsheet.core.flowsheet.Flowsheet.draw">draw</a></code></li>
<li><code><a title="pyflowsheet.core.flowsheet.Flowsheet.unit" href="#pyflowsheet.core.flowsheet.Flowsheet.unit">unit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>